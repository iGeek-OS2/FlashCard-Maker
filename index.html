<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlashMaker Web</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&family=Noto+Sans+JP:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
</head>
<body>
    <div id="app"></div>
    <div id="toast-container"></div>

    <script>
        // 安全な設計のため、このファイルにはAPIキーやトークンは一切含みません。

        const AppState = {
            INITIAL: 'initial',
            FLASHCARDS: 'flashcards',
            FINISHED: 'finished',
            ERROR: 'error'
        };

        let appState = AppState.INITIAL;
        let errorMessage = '';
        let flashCards = [];
        let currentCardIndex = 0;
        let isFlipped = false;
        let correctAnswers = 0;
        let selectedCardCount = 20;
        let isGenerating = false;
        let isPDFLoaded = false;
        let loadedPDFText = '';
        
        function setState(newState, newErrorMessage = '') {
            appState = newState;
            errorMessage = newErrorMessage;
            render();
        }
        
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => { toast.classList.add('show'); }, 10);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => { if (container.contains(toast)) { container.removeChild(toast); } }, 500);
            }, duration);
        }

        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === "application/pdf") {
                showToast("PDFを読み込んでいます...", "info", 60000);
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    let textContent = '';
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const text = await page.getTextContent();
                        textContent += text.items.map(s => s.str).join(' ');
                    }
                    loadedPDFText = textContent;
                    isPDFLoaded = true;
                    showToast("PDFの読み込みが完了しました！", "success");
                } catch (err) {
                    setState(AppState.ERROR, `PDFの解析に失敗しました: ${err.message}`);
                } finally {
                    document.querySelector('.toast')?.remove();
                    render();
                }
            } else {
                 showToast("PDFファイルを選択してください。", "error");
            }
        }
        
        async function handleJsonFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.type === "application/json") {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    if (data.flashcards && Array.isArray(data.flashcards)) {
                        flashCards = data.flashcards.sort(() => 0.5 - Math.random());
                        currentCardIndex = 0;
                        correctAnswers = 0;
                        isFlipped = false;
                        setState(AppState.FLASHCARDS);
                    } else { throw new Error("JSONのフォーマットが正しくありません。"); }
                } catch (err) {
                     setState(AppState.ERROR, `JSONの読み込みに失敗しました: ${err.message}`);
                }
            } else {
                showToast("JSONファイルを選択してください。", "error");
            }
        }

        async function generateFlashcards() {
            if (!loadedPDFText) {
                setState(AppState.ERROR, "PDFが読み込まれていません。");
                return;
            }

            isGenerating = true;
            render();
            showToast("AIがカードを生成中です...", "info", 20000);

            try {
                // Netlify上のプロキシ関数にリクエストを送信
                const response = await fetch('/.netlify/functions/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pdfText: loadedPDFText,
                        cardCount: selectedCardCount
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `サーバーエラーが発生しました (ステータス: ${response.status})`);
                }

                const data = await response.json();

                if (data.flashcards && Array.isArray(data.flashcards)) {
                    flashCards = data.flashcards.sort(() => 0.5 - Math.random());
                    currentCardIndex = 0;
                    correctAnswers = 0;
                    isFlipped = false;
                    setState(AppState.FLASHCARDS);
                    showToast("カードの生成が完了しました！", "success");
                } else {
                    throw new Error("AIから予期しない形式のデータが返されました。");
                }

            } catch (error) {
                setState(AppState.ERROR, `生成に失敗しました: ${error.message}`);
            } finally {
                isGenerating = false;
                render();
            }
        }
        
        // ... (handleCardFlip, handleAnswer, restartQuiz, backToHome, exportAsJSON, exportForWordHolic, render, attachEventListenersなどの関数は変更ありません)
        function handleCardFlip() {
            const cardInner = document.querySelector('.card-inner');
            if (cardInner) {
                isFlipped = !isFlipped;
                cardInner.style.transform = isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)';
            }
        }
        function handleAnswer(isCorrect) {
            if (isCorrect) { correctAnswers++; }
            if (currentCardIndex < flashCards.length - 1) {
                currentCardIndex++;
                isFlipped = false;
                render();
            } else { setState(AppState.FINISHED); }
        }
        function restartQuiz() {
            flashCards = flashCards.sort(() => 0.5 - Math.random());
            currentCardIndex = 0;
            correctAnswers = 0;
            isFlipped = false;
            setState(AppState.FLASHCARDS);
        }
        function backToHome() {
            loadedPDFText = '';
            isPDFLoaded = false;
            flashCards = [];
            currentCardIndex = 0;
            correctAnswers = 0;
            isFlipped = false;
            setState(AppState.INITIAL);
        }
        function exportAsJSON() {
            const exportData = { flashcards: flashCards };
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flashcards.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        function exportForWordHolic() {
            const header = "FrontText,BackText,Comment,FrontTextLanguage,BackTextLanguage\n";
            const csvRows = flashCards.map(card => `"${card.frontText.replace(/"/g, '""')}",\"${card.backText.replace(/"/g, '""')}",,ja-JP,ja-JP`).join("\n");
            const csvString = header + csvRows;
            const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'wordholic_cards.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        function render() {
            const app = document.getElementById('app');
            app.innerHTML = '';
            
            switch (appState) {
                case AppState.INITIAL:
                    app.innerHTML = `
                        <div class="container initial-container">
                             <div class="title-cluster"><span class="title-icon">✨</span><h1>FlashMaker</h1></div>
                             <p class="subtitle">PDFからAIが自動で暗記カードを作成します。</p>
                             <div class="main-card">
                                 <label class="custom-file-upload ${isPDFLoaded ? 'loaded' : ''}">
                                     <input type="file" id="pdf-upload" accept=".pdf"/>
                                     <span class="icon">📄</span> ${isPDFLoaded ? 'PDF読み込み完了！' : 'PDFを読み込み'}
                                 </label>
                                 <div class="control-group">
                                     <div class="control-icon">🔢</div>
                                     <div class="control-text">
                                         <div class="control-label">カード枚数</div>
                                         <div class="control-value">${selectedCardCount}枚作成する</div>
                                     </div>
                                     <div class="menu-container">
                                         <button id="count-menu-btn" class="menu-button">変更</button>
                                         <div id="count-menu" class="menu-dropdown">
                                             <a href="#" data-count="10">10枚</a><a href="#" data-count="20">20枚</a>
                                             <a href="#" data-count="30">30枚</a><a href="#" data-count="40">40枚</a>
                                         </div>
                                     </div>
                                 </div>
                                 <button id="generate-btn" class="generate-button" ${!isPDFLoaded || isGenerating ? 'disabled' : ''}>
                                     ${isGenerating ? '<div class="loader"></div> 作成中...' : '暗記カードを作成'}
                                 </button>
                             </div>
                             <label class="secondary-upload">
                                <input type="file" id="json-upload" accept=".json"/>
                                <span class="icon">📥</span> カードデータを読み込む
                             </label>
                        </div>`;
                    break;
                case AppState.FLASHCARDS:
                    const c = flashCards[currentCardIndex];
                    app.innerHTML = `
                        <div class="container flashcard-container">
                            <p class="progress-text">第${currentCardIndex + 1}問 / ${flashCards.length}問</p>
                            <div class="card-scene">
                                <div class="card-inner">
                                    <div class="card-face card-front">${c.frontText}</div>
                                    <div class="card-face card-back">${c.backText}</div>
                                </div>
                            </div>
                            <div class="answer-buttons">
                                <button id="incorrect-btn" class="answer-btn incorrect">不正解</button>
                                <button id="correct-btn" class="answer-btn correct">正解</button>
                            </div>
                        </div>`;
                    break;
                case AppState.FINISHED:
                    const correctP = flashCards.length > 0 ? (correctAnswers / flashCards.length) * 100 : 0;
                    const incorrectC = flashCards.length - correctAnswers;
                    const incorrectP = flashCards.length > 0 ? (incorrectC / flashCards.length) * 100 : 0;
                    app.innerHTML = `
                        <div class="container finished-container">
                            <div class="main-card result-card">
                                <h2>結果</h2><p class="result-subtitle">今回の成績です</p>
                                <div class="result-circles">
                                    <div class="result-circle">
                                        <svg viewBox="0 0 36 36"><path class="circle-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" /><path class="circle correct" stroke-dasharray="${correctP}, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" /></svg>
                                        <div class="result-count">${correctAnswers}</div><div class="result-label">正解</div>
                                    </div>
                                    <div class="result-circle">
                                        <svg viewBox="0 0 36 36"><path class="circle-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" /><path class="circle incorrect" stroke-dasharray="${incorrectP}, 100" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831" /></svg>
                                        <div class="result-count">${incorrectC}</div><div class="result-label">不正解</div>
                                    </div>
                                </div>
                                <div class="result-actions">
                                    <button id="restart-btn" class="result-btn">もう一度挑戦</button>
                                    <button id="home-btn" class="result-btn">タイトルに戻る</button>
                                </div>
                                <div class="export-actions">
                                    <button id="export-json-btn">JSONで共有</button>
                                    <button id="export-wordholic-btn">WordHolic形式で共有</button>
                                </div>
                            </div>
                        </div>`;
                    break;
                case AppState.ERROR:
                    app.innerHTML = `
                         <div class="container error-container">
                             <div class="main-card">
                                 <div class="error-icon">⚠️</div><h2>エラーが発生しました</h2>
                                 <p class="error-message">${errorMessage}</p>
                                 <button id="home-btn" class="result-btn">最初に戻る</button>
                             </div>
                         </div>`;
                    break;
            }
            attachEventListeners();
        }
        function attachEventListeners() {
            if (appState === AppState.INITIAL) {
                document.getElementById('pdf-upload')?.addEventListener('change', handleFileSelect);
                document.getElementById('json-upload')?.addEventListener('change', handleJsonFileSelect);
                document.getElementById('generate-btn')?.addEventListener('click', generateFlashcards);
                const menuBtn = document.getElementById('count-menu-btn');
                const menu = document.getElementById('count-menu');
                menuBtn?.addEventListener('click', () => menu.classList.toggle('show'));
                document.querySelectorAll('#count-menu a').forEach(item => {
                    item.addEventListener('click', e => {
                        e.preventDefault();
                        selectedCardCount = parseInt(e.target.dataset.count, 10);
                        menu.classList.remove('show');
                        render();
                    });
                });
                window.addEventListener('click', (e) => {
                    if (menu && menuBtn && !menuBtn.contains(e.target) && !menu.contains(e.target)) {
                        menu.classList.remove('show');
                    }
                });
            } else if (appState === AppState.FLASHCARDS) {
                document.querySelector('.card-scene')?.addEventListener('click', handleCardFlip);
                document.getElementById('correct-btn')?.addEventListener('click', () => handleAnswer(true));
                document.getElementById('incorrect-btn')?.addEventListener('click', () => handleAnswer(false));
            } else if (appState === AppState.FINISHED) {
                document.getElementById('restart-btn')?.addEventListener('click', restartQuiz);
                document.getElementById('home-btn')?.addEventListener('click', backToHome);
                document.getElementById('export-json-btn')?.addEventListener('click', exportAsJSON);
                document.getElementById('export-wordholic-btn')?.addEventListener('click', exportForWordHolic);
            } else if (appState === AppState.ERROR) {
                document.getElementById('home-btn')?.addEventListener('click', backToHome);
            }
        }
        document.addEventListener('DOMContentLoaded', render);

    </script>
</body>
</html>
